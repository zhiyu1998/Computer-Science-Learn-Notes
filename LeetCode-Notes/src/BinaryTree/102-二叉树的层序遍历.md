# äºŒå‰æ ‘çš„å±‚åºéå†
https://leetcode-cn.com/problems/binary-tree-level-order-traversal/

## é—®é¢˜æè¿°
ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ å±‚åºéå† ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

## ç¬¬ä¸€æ€è·¯: é˜Ÿåˆ—æ–¹å¼è§£å†³
```java
//ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚ 
//
// 
//
// ç¤ºä¾‹ 1ï¼š 
//
// 
//è¾“å…¥ï¼šroot = [1,2,2,3,4,4,3]
//è¾“å‡ºï¼štrue
// 
//
// ç¤ºä¾‹ 2ï¼š 
//
// 
//è¾“å…¥ï¼šroot = [1,2,2,null,3,null,3]
//è¾“å‡ºï¼šfalse
// 
//
// 
//
// æç¤ºï¼š 
//
// 
// æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ [1, 1000] å†… 
// -100 <= Node.val <= 100 
// 
//
// 
//
// è¿›é˜¶ï¼šä½ å¯ä»¥è¿ç”¨é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹æ³•è§£å†³è¿™ä¸ªé—®é¢˜å—ï¼Ÿ 
// Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ äºŒå‰æ ‘ ğŸ‘ 1773 ğŸ‘ 0


//leetcode submit region begin(Prohibit modification and deletion)

import java.util.LinkedList;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new LinkedList<>();

        // ç¬¬ä¸€å±‚
        if (root == null)
            return ans;
        else {
            final List<Integer> temp = new LinkedList<>();
            temp.add(root.val);
            ans.add(temp);
        }

        // å¦‚æœåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹
        if (root.left == null && root.right == null)
            return ans;

        // ç¬¬äºŒå±‚
        LinkedList<TreeNode> curG = new LinkedList<>();
        LinkedList<TreeNode> nextG = new LinkedList<>();

        if (root.left != null)
            curG.add(root.left);
        if (root.right != null)
            curG.add(root.right);

        // å…¶ä»–å±‚ï¼ˆ>2ï¼‰
        while (curG.size() > 0) {
            List<Integer> elList = new LinkedList<>();

            // åŠ å…¥ä¸Šä¸€æ¬¡çš„ç­”æ¡ˆ, æ¸…é™¤é˜Ÿåˆ—å…ƒç´ 
            while (curG.size() > 0) {
                final TreeNode node = curG.removeFirst();
                elList.add(node.val);
                // æ·»åŠ å·¦èŠ‚ç‚¹å’Œå³èŠ‚ç‚¹
                if (el.left != null)
                    nextG.add(el.left);
                if (el.right != null)
                    nextG.add(el.right);
            }

            // æ·»åŠ é˜Ÿåˆ—å…ƒç´ 
            ans.add(elList);
            curG.addAll(nextG);
            nextG.clear();
        }

        return ans;
    }
}
```

> æ‰§è¡Œç»“æœï¼š é€šè¿‡  
æ‰§è¡Œç”¨æ—¶ï¼š1 ms, åœ¨æ‰€æœ‰ Java æäº¤ä¸­å‡»è´¥äº† 79.04% çš„ç”¨æˆ·  
å†…å­˜æ¶ˆè€—ï¼š41.2 MB, åœ¨æ‰€æœ‰ Java æäº¤ä¸­å‡»è´¥äº† 40.13% çš„ç”¨æˆ·


## æ€»ç»“: BFS vs DFS
DFSï¼ˆæ·±åº¦ä¼˜å…ˆæœç´¢ï¼‰å’Œ BFSï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰
### DFS ä¸ BFSåŒºåˆ«
> DFSéå†
```java
void dfs(TreeNode root) {
    if (root == null) {
        return;
    }
    dfs(root.left);
    dfs(root.right);
}

```

> BFSéå†
```java
void bfs(TreeNode root) {
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll(); // Java çš„ pop å†™ä½œ poll()
        if (node.left != null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
    }
}

```
åªæ˜¯æ¯”è¾ƒä¸¤æ®µä»£ç çš„è¯ï¼Œæœ€ç›´è§‚çš„æ„Ÿå—å°±æ˜¯ï¼šDFS éå†çš„ä»£ç æ¯” BFS ç®€æ´å¤ªå¤šäº†ï¼è¿™æ˜¯å› ä¸ºé€’å½’çš„æ–¹å¼éšå«åœ°ä½¿ç”¨äº†ç³»ç»Ÿçš„ æ ˆï¼Œæˆ‘ä»¬ä¸éœ€è¦è‡ªå·±ç»´æŠ¤ä¸€ä¸ªæ•°æ®ç»“æ„ã€‚å¦‚æœåªæ˜¯ç®€å•åœ°å°†äºŒå‰æ ‘éå†ä¸€éï¼Œé‚£ä¹ˆ DFS æ˜¾ç„¶æ˜¯æ›´æ–¹ä¾¿çš„é€‰æ‹©ã€‚

### BFS çš„åº”ç”¨ä¸€ï¼šå±‚åºéå†
https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/
### BFS çš„åº”ç”¨äºŒï¼šæœ€çŸ­è·¯å¾„
https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/